---
---

<h1>Internationalization</h1>

<p>Providing software for users in the whole world means providing it in
multiple languages. This consists of two steps:</p>
<ul>
    <li><em>Internationalization (i18n)</em> - Making the software
    international, i. e. preparing it to be adapted to different languages and
    locations.</li>
    <li><em>Localization (L10n)</em> - Adapting the software to a particular
    language and/or location.</li>
</ul>
<p>The Open-Xchange platform offers several facilities to simplify both parts.
The L10n part is mostly a concern for translators. Open-Xchange facilities for
that consist mainly of using a well-established format for translations:
<a href="http://www.gnu.org/s/gettext/" target="_blank">GNU Gettext</a> Portable
Object (PO) files. This allows translators to use existing dedicated translation
tools or a simple UTF-8-capable text editor.</p>
<p>The i18n part is what software developers will be mostly dealing with and is
what the rest of this document describes.</p>

<h2>Translation</h2>

<p>The main part of i18n is the translation of various text strings which are
presented to the user. For this purpose, the Open-Xchange platform provides
the RequireJS plugin <code>'gettext'</code>. Individual translation files are
specified as a module dependency of the form
<code>'gettext!<var>module_name</var>'</code>. The resulting module API is
a function which can be called to translate a string using the specified
translation files:</p>
<script type="text/example">
define('com.example/example', ['gettext!com.example/example'],
    function (gt) {
        'use strict';
        alert(gt('Hello, world!'));
    });
</script>
<p>After building the module, the file ox.pot in the project's root directory
will contain an entry for every call to one of <code>gettext</code> functions:
</p>
<pre class="nocode prettyprint">
<code class="com">#: apps/com.example/example.js:4</code>
<code class="kwd">msgid</code> <code class="str">"Hello, world!"</code>
<code class="kwd">msgstr</code> <code class="str">""</code>
</pre>
<p>After translation, the PO files in the directory <code>i18n</code> shoud
contain the translated entry:</p>
<pre class="nocode prettyprint">
<code class="com">#: apps/com.example/example.js:4</code>
<code class="kwd">msgid</code> <code class="str">"Hello, world!"</code>
<code class="kwd">msgstr</code> <code class="str">"Hallo, Welt!"</code>
</pre>
<p>During the next build, the entries are copied from the central PO files
into individual translation files. In our example, this would be
<code>apps/com.example/example.de_DE.js</code>. Because of the added language
ID, translation files can usually have the same name as the corresponding main
module. Multiple related modules should use the same translation file to avoid
the overhead of too many small translation files.</p>

<p>Most modules will require more complex translations than can be provided by
a simple string lookup. To handle some of these cases, the <code>gettext</code>
module provides traditional methods in addition to being a callable function.
Other cases are handled by the build system.</p>

<h2>Composite Phrases</h2>

<p>In most cases, the translated texts will not be static, but contain dynamic
values as parts of a sentence. The straight-forward approach of translating
parts of the sentence individually and then using string concatenation to
compose the final text is a <em><st>BAD</st></em> idea. Different languages have
different sentence structures, and if there are multiple dynamic values, their
order might need to be reversed in some languages, and not reversed in others.
</p>
<p>The solution is to translate entire sentences and then to use the
<code>gettext</code> function to insert dynamic values:</p>
<script type="text/example">
alert(
    //#. %1$s is the given name
    //#. %2$s is the family name
    //#, c-format
    gt('Welcome, %1$s %2$s!', firstName, lastName));
</script>
<p>Results in:</p>
<pre class="nocode prettyprint">
<code class="com">#. %1$s is the given name</code>
<code class="com">#. %2$s is the family name</code>
<code class="com">#, c-format</code>
<code class="kwd">msgid</code> <code class="str">"Welcome, %1$s, %2$s"</code>
<code class="kwd">msgstr</code> <code class="str">""</code>
</pre>
<p>As shown in the example, it is possible to add comments for translators by
starting a comment with "<code>#.</code>". Such comments must be placed
immediately before the name of the variable which refers to
the <code>gettext</code> module (in this case <code>gt</code>). They can be
separated by arbitrary whitespace and newlines, but not other tokens. All such
<code>gettext</code> calls should have comments explaining every format
specifier.</p>
<p>Comments starting with "<code>#,</code>" are meant for Gettext tools, which
in the case of "<code>#, c-format</code>", can ensure that the translator did
not leave out or mistype any of the format specifiers.</p>
<p>For the cases when the format string must be translated by one of
the functions described below, there is a dedicated format function
<code>gettext.format</code> which, except for debugging, is an alias for
<code>_.printf</code>.</p>

<h2>Debugging</h2>

<p>One of the most common i18n errors is forgetting to use
a <code>gettext</code> function. To catch this kind of error, the UI can be
started with the hash parameter "<code>#debug-i18n=1</code>". (Reloading of
the browser tab is usually required for the setting to take effect.)</p>
<p>In this mode, every translated string is marked with invisible Unicode
characters, and any DOM text without those characters gets reported on the
console. The <code>gettext.format</code> function then also checks that every
parameter is translated. This is the reason why <code>_.printf</code> should not
be used for user-visible strings directly.</p>
<p>Unfortunately, this method will also report any string which does not
actually require translation. Examples of such strings include user data,
numbers, strings already translated by the server, etc. To avoid filling
the console with such false positives, every such string must be marked by
passing it through the function <code>gettext.noI18n</code>:</p>
<script type="text/example">
alert(
    //#. %1$s is the given name
    //#. %2$s is the family name
    //#, c-format
    gt('Welcome, %1$s %2$s!', gt.noI18n(firstName), gt.noI18n(lastName)));
</script>
<p>This results in the strings being marked as 'translated' without actually
changing their visible contents. When not debugging, <code>gettext.noI18n</code>
simply returns its first parameter.</p>

<h2>Advanced <code>gettext</code> Functions</h2>

<p>Besides <code>gettext.format</code> and <code>gettext.noI18n</code> there
are several other functions which are required to cover all typical translation
scenarios.</p>

<h3>Contexts</h3>

<p>Sometimes, the same English word or phrase has multiple meanings and must be
translated differently depending on context. To be able to tell
the individual translations apart, the method <code>gettext.pgettext</code>
('p' stands for 'particular') should be used instead of calling
<code>gettext</code> directly. It takes the context as the first parameter
and the text to translate as the second parameter:</p>
<script type="text/example">
alert(gt.pgettext('description', 'Title'));
alert(gt.pgettext('salutation', 'Title'));
</script>
<p>Results in:</p>
<pre class="nocode prettyprint">
<code class="kwd">msctxt</code> <code class="str">"description"</code>
<code class="kwd">msgid</code> <code class="str">"Title"</code>
<code class="kwd">msgstr</code> <code class="str">"Beschreibung"</code>

<code class="kwd">msctxt</code> <code class="str">"salutation"</code>
<code class="kwd">msgid</code> <code class="str">"Title"</code>
<code class="kwd">msgstr</code> <code class="str">"Anrede"</code>
</pre>

<h3>Plural forms</h3>

<p>In the case of numbers, the rules to select the proper plural form can be
very complex. With the exception of languages with no separate plural forms,
English is the second simplest language in this respect, having only two plural
forms: singular and plural. Other languages can have up to four forms, and
theoretically even more. The functions <code>gettext.ngettext</code> and
<code>gettext.npgettext</code> (for a combination of plural forms with contexts)
can select the proper plural form by using a piece of executable code embedded
in the header of a PO file:</p>
<script type="text/example">
alert(gt.format(
    //#. %1$d is the number of mails
    //#, c-format
    gt.ngettext('You have %1$d mail', 'You have %1$d mails', n),
    gt.noI18n(n)));
</script>
<p>The function <code>gettext.ngettext</code> accepts three parameters:
the English singular and plural forms and the number which determines the chosen
plural form. The function <code>gettext.npgettext</code> adds a context
parameter before the others, similar to <code>gettext.pgettext</code>. They are
usually used in combination with <code>gettext.format</code> to insert
the actual number into the translated string.</p>
<p>The above example results in the following entry:</p>
<pre class="nocode prettyprint">
<code class="com">#. %1$d is the number of mails</code>
<code class="com">#, c-format</code>
<code class="kwd">msgid</code> <code class="str">"You have %1$d mail"</code>
<code class="kwd">msgid_plural</code> <code class="str">"You have %1$d mails"</code>
<code class="kwd">msgstr[0]</code> <code class="str">""</code>
<code class="kwd">msgstr[1]</code> <code class="str">""</code>
</pre>
<p>The number of <code>msgstr[<var>N</var>]</code> lines is determined by
the number of plural forms in each language. This number is specified in the
header of each PO file, together with the code to compute the index of
the correct plural form the supplied number.</p>
